#!/bin/bash
# ==============================================================================
# OKnav System - Multi-server SSH Command Orchestrator
# ==============================================================================
# Executes commands across all cluster servers defined in hosts.conf.
# Servers must have (oknav) option to be included in cluster operations.
#
# Subcommands:
#   (default)    Execute command on all (oknav) servers
#   install      Create/manage symlinks in /usr/local/bin from hosts.conf
#   add          Create ad-hoc host launcher (requires sudo)
#   remove       Remove ad-hoc host launcher (requires sudo)
#   list         List installed host symlinks and their source
#
# Use -- to force multi-execute mode (bypass subcommand detection):
#   oknav -- list uptime    Execute 'list uptime' on servers, not list subcommand
#
# Exit codes:
#   0   Success
#   1   General error (no servers, missing config, etc.)
#   22  Invalid option (EINVAL)
#
# See also: ok_master (individual server handler), common.inc.sh (shared lib)
# ==============================================================================
set -euo pipefail
shopt -s inherit_errexit

SCRIPT_PATH=$(realpath -e -- "$0")
SCRIPT_DIR=${SCRIPT_PATH%/*}
SCRIPT_NAME=${SCRIPT_PATH##*/}
readonly -- SCRIPT_PATH SCRIPT_DIR SCRIPT_NAME

#shellcheck source=common.inc.sh
source "$SCRIPT_DIR"/common.inc.sh || exit 1

# ------------------------------------------------------------------------------
# Runtime Configuration
# ------------------------------------------------------------------------------
declare -i PARALLEL=0              # Execution mode: 0=sequential, 1=parallel
declare -i TIMEOUT=30              # SSH connection timeout in seconds
declare -i FORCE_EXEC=0            # Force multi-execute mode (bypass subcommands)
declare -a TEMP_FILES=()           # Temp files to clean up on exit
declare -a ok_server_excludes=()   # Servers excluded via -x option

# Working variables (declared here to satisfy strict mode)
declare -i exit_code               # Captured exit code from ssh/timeout
declare -- server                  # Current server alias being processed
declare -- pid                     # Background process ID (parallel mode)
declare -- temp_file               # Path to server output temp file
declare -- temp_file_path          # Path to temp file reference marker

# ------------------------------------------------------------------------------
# cleanup() - Remove temporary files and exit
# Args: [exit_code] - Exit code to preserve (default: 0)
# Called by: trap on SIGINT, SIGTERM, EXIT
# ------------------------------------------------------------------------------
cleanup() {
  local -i exitcode=${1:-0}
  trap - SIGINT SIGTERM EXIT  # Prevent recursion
  # Remove tracked temp files
  local -- file
  for file in "${TEMP_FILES[@]}"; do
    [[ -f "$file" ]] && rm -f "$file"
  done
  # Remove orphaned temp files (parallel subshells don't update TEMP_FILES)
  rm -f "${TEMP_DIR:-/tmp}"/"${SCRIPT_NAME:-}"_*_* 2>/dev/null || true
  rm -f "${TEMP_DIR:-/tmp}"/."${SCRIPT_NAME:-}"_*_tempfile 2>/dev/null || true
  exit "$exitcode"
}
trap 'cleanup $?' SIGINT SIGTERM EXIT

# ------------------------------------------------------------------------------
# usage() - Display help message
# ------------------------------------------------------------------------------
usage() {
  cat <<EOT
$SCRIPT_NAME $VERSION - Multi-server SSH command orchestrator

Execute commands across all cluster servers. Servers are discovered from
hosts.conf entries marked with (oknav) option.

Usage:
  $SCRIPT_NAME [OPTIONS] <command>          Execute command on all servers
  $SCRIPT_NAME [OPTIONS] -- <command>       Force multi-execute (bypass subcommands)
  $SCRIPT_NAME install [OPTIONS]            Manage symlinks from hosts.conf
  $SCRIPT_NAME add <hostname> [alias...]    Add ad-hoc launcher (sudo required)
  $SCRIPT_NAME remove <alias>...            Remove launcher (sudo required)
  $SCRIPT_NAME list                         List installed host symlinks

Options:
  -p, --parallel           Execute on all servers simultaneously
  -t, --timeout SECS       Connection timeout (default: $TIMEOUT)
  -x, --exclude-host HOST  Exclude host from this run (repeatable)
  -D, --debug              Show server discovery and execution details
  -V, --version            Show version
  -h, --help               Show this help

Server Filtering (automatic):
  (oknav)            Required for inclusion in cluster operations
  (exclude)          Excluded from cluster (can still access directly)
  (local-only:HOST)  Only accessible from specified host

Examples:
  $SCRIPT_NAME uptime                       Sequential execution (default)
  $SCRIPT_NAME -p 'df -h'                   Parallel execution
  $SCRIPT_NAME -x ok0 -x ok1 uptime         Exclude multiple hosts
  $SCRIPT_NAME -pt 10 uptime                Parallel + 10s timeout
  $SCRIPT_NAME -- list /tmp                 Force 'list /tmp' as command (not subcommand)
  $SCRIPT_NAME install --dry-run            Preview symlink changes
  $SCRIPT_NAME add ai.okusi.id ai           Create 'ai' launcher for ai.okusi.id
  $SCRIPT_NAME remove ai                    Remove 'ai' launcher

EOT
}

# ------------------------------------------------------------------------------
# install_symlinks() - Create/manage symlinks in /usr/local/bin
# Creates symlinks for all aliases defined in hosts.conf, pointing to ok_master.
# Options: -n/--dry-run, --remove-stale, --clean-local
# Returns: 0 on success, 22 on invalid option
# ------------------------------------------------------------------------------
install_symlinks() {
  local -i dry_run=0 remove_stale=0 clean_local=0
  local -- target_dir=/usr/local/bin
  local -i created=0 updated=0 skipped=0 removed=0

  # Locate ok_master: prefer installed location, fall back to dev directory
  local -- ok_master=/usr/local/share/oknav/ok_master
  [[ -f "$ok_master" ]] || ok_master="$SCRIPT_DIR"/ok_master

  while (($#)); do
    case $1 in
      -n|--dry-run) dry_run=1 ;;
      --remove-stale) remove_stale=1 ;;
      --clean-local) clean_local=1 ;;
      -h|--help)
          cat <<-EOT
	Usage: $SCRIPT_NAME install [OPTIONS]

	Create symlinks in /usr/local/bin for all hosts.conf aliases.

	Options:
	  -n, --dry-run      Preview changes without modifying filesystem
	  --remove-stale     Remove symlinks not in hosts.conf
	  --clean-local      Remove dev symlinks from script directory
	  -h, --help         Show this help
	EOT
        return 0
        ;;
      *)
        error "Unknown install option ${1@Q}"
        return 22
        ;;
    esac
    shift
  done

  # Load hosts.conf (auto-detects /etc/oknav/ or script directory)
  #shellcheck disable=SC2119
  load_hosts_conf

  # Check for aliases that conflict with subcommand names
  local -a reserved_names=(install add remove list help)
  local -- alias_name reserved
  for alias_name in "${ALIAS_LIST[@]}"; do
    for reserved in "${reserved_names[@]}"; do
      if [[ "$alias_name" == "$reserved" ]]; then
        warn "alias '$alias_name' conflicts with oknav subcommand"
        warn "  use 'oknav -- $alias_name <cmd>' to execute on this server"
      fi
    done
  done

  info "Installing symlinks to ${target_dir@Q}..."
  ((dry_run)) && info "(dry-run mode - no changes will be made)"

  # Create symlinks for all aliases in hosts.conf
  local -- alias target
  for alias in "${ALIAS_LIST[@]}"; do
    target="$target_dir/$alias"
    if [[ -L "$target" ]]; then
      if [[ "$(readlink "$target")" == "$ok_master" ]]; then
        ((++skipped))
      else
        info "  update: $alias (was: $(readlink "$target"))"
        ((dry_run)) || ln -sf "$ok_master" "$target"
        ((++updated))
      fi
    elif [[ -e "$target" ]]; then
      warn "$alias: file exists and is not a symlink - skipping"
    else
      info "  create: $alias"
      ((dry_run)) || ln -sf "$ok_master" "$target"
      ((++created))
    fi
  done

  # Remove stale symlinks (pointing to ok_master but not in hosts.conf)
  if ((remove_stale)); then
    local -- link name
    for link in "$target_dir"/ok*; do
      [[ -L "$link" ]] || continue
      [[ "$(readlink "$link")" == "$ok_master" ]] || continue
      name="${link##*/}"
      [[ -n "${ALIAS_TO_FQDN[$name]:-}" ]] && continue
      info "  remove: $name (not in hosts.conf)"
      ((dry_run)) || rm -f "$link"
      ((++removed))
    done
  fi

  # Clean local symlinks
  if ((clean_local)); then
    local -- link name
    for link in "$SCRIPT_DIR"/ok*; do
      [[ -L "$link" ]] || continue
      name="${link##*/}"
      info "  remove local: $name"
      ((dry_run)) || rm -f "$link"
      ((++removed))
    done
  fi

  echo
  info "Summary: $created created, $updated updated, $skipped unchanged, $removed removed"
  return 0
}

# ------------------------------------------------------------------------------
# add_host() - Create ad-hoc host launcher symlinks
# Creates symlinks in /usr/local/bin → ok_master for quick SSH access.
# Hostname must be resolvable via DNS/hosts. Requires sudo.
# Args: [-n] <hostname> [alias...]
# Returns: 0 success, 1 error (unresolvable host), 22 invalid option
# ------------------------------------------------------------------------------
add_host() {
  local -i dry_run=0
  local -- target_dir=/usr/local/bin

  # Locate ok_master: prefer installed location, fall back to dev directory
  local -- ok_master=/usr/local/share/oknav/ok_master
  [[ -f "$ok_master" ]] || ok_master="$SCRIPT_DIR"/ok_master

  while (($#)); do
    case $1 in
      -n|--dry-run) dry_run=1 ;;
      -h|--help)
        cat <<-'EOT'
	Usage: oknav add [-n] <hostname> [alias...]

	Create symlinks for quick SSH access to a host (requires sudo).
	The hostname must be resolvable via DNS or /etc/hosts.

	Arguments:
	  hostname    FQDN or IP address (must be resolvable)
	  alias...    Symlink names (defaults to hostname if omitted)

	Options:
	  -n, --dry-run   Preview changes without modifying filesystem
	  -h, --help      Show this help

	Examples:
	  oknav add ai.okusi.id             Creates: ai.okusi.id → ok_master
	  oknav add ai.okusi.id ai ok-ai    Creates: ai, ok-ai → ok_master

	Note: Symlinks are created in /usr/local/bin using sudo.
	EOT
        return 0 ;;
      -*) error "Unknown option ${1@Q}"; return 22 ;;
      *) break ;;
    esac
    shift
  done

  # Require hostname
  (($#)) || { error "Usage: oknav add [-n] <hostname> [alias...]"; return 1; }

  local -- hostname=$1; shift

  # Validate hostname is resolvable
  if ! getent hosts "$hostname" &>/dev/null; then
    error "Cannot resolve hostname: $hostname"
    return 1
  fi

  # Use hostname as alias if none provided
  local -a aliases=("${@:-$hostname}")

  ((dry_run)) && info "(dry-run mode - no changes will be made)"

  # Create symlinks (requires sudo for /usr/local/bin)
  local -- alias target reply
  for alias in "${aliases[@]}"; do
    target="$target_dir/$alias"
    if [[ -L "$target" ]]; then
      if [[ "$(readlink "$target")" == "$ok_master" ]]; then
        info "skip: $alias (already points to ok_master)"
      else
        # Symlink exists but points elsewhere
        if [[ -t 0 && -t 1 ]]; then
          # Interactive: prompt user
          read -rp "oknav: $alias exists (→ $(readlink "$target")). Overwrite? [y/N] " reply
          [[ "$reply" =~ ^[Yy] ]] || { info "skip: $alias"; continue; }
        fi
        info "update: $alias (was: $(readlink "$target"))"
        ((dry_run)) || sudo ln -sf "$ok_master" "$target"
      fi
    elif [[ -e "$target" ]]; then
      warn "$alias: file exists and is not a symlink - skipping"
    else
      info "create: $alias → $hostname"
      ((dry_run)) || sudo ln -sf "$ok_master" "$target"
    fi
  done
}

# ------------------------------------------------------------------------------
# remove_host() - Remove ad-hoc host launcher symlinks
# Removes symlinks from /usr/local/bin that point to ok_master. Requires sudo.
# Only removes symlinks pointing to ok_master; ignores other files.
# Args: [-n] <alias>...
# Returns: 0 always (warnings for non-existent/non-symlink files)
# ------------------------------------------------------------------------------
remove_host() {
  local -i dry_run=0
  local -- target_dir=/usr/local/bin

  # Locate ok_master for symlink validation
  local -- ok_master=/usr/local/share/oknav/ok_master
  [[ -f "$ok_master" ]] || ok_master="$SCRIPT_DIR"/ok_master

  while (($#)); do
    case $1 in
      -n|--dry-run) dry_run=1 ;;
      -h|--help)
        cat <<-'EOT'
	Usage: oknav remove [-n] <alias>...

	Remove symlinks created by 'oknav add' (requires sudo).
	Only removes symlinks that point to ok_master.

	Options:
	  -n, --dry-run   Preview changes without modifying filesystem
	  -h, --help      Show this help

	Examples:
	  oknav remove ai                   Remove single symlink
	  oknav remove ai ok-ai             Remove multiple symlinks

	Note: Symlinks are removed from /usr/local/bin using sudo.
	EOT
        return 0 ;;
      -*) error "Unknown option ${1@Q}"; return 22 ;;
      *) break ;;
    esac
    shift
  done

  # Require at least one alias
  (($#)) || { error "Usage: oknav remove [-n] <alias>..."; return 1; }

  ((dry_run)) && info "(dry-run mode - no changes will be made)"

  # Remove symlinks (requires sudo for /usr/local/bin)
  local -- alias target
  for alias in "$@"; do
    target="$target_dir/$alias"
    if [[ -L "$target" ]]; then
      if [[ "$(readlink "$target")" == "$ok_master" ]]; then
        info "remove: $alias"
        ((dry_run)) || sudo rm -f "$target"
      else
        warn "$alias: symlink points elsewhere - skipping"
      fi
    elif [[ -e "$target" ]]; then
      warn "$alias: not a symlink - skipping"
    else
      warn "$alias: does not exist"
    fi
  done
}

# ------------------------------------------------------------------------------
# list_hosts() - List all host symlinks pointing to ok_master
# Shows which hosts are defined in hosts.conf vs ad-hoc additions.
# Args: [-h|--help]
# Returns: 0 always
# ------------------------------------------------------------------------------
list_hosts() {
  local -- target_dir=${OKNAV_TARGET_DIR:-/usr/local/bin}

  # Locate ok_master: prefer installed location, fall back to dev directory
  local -- ok_master=/usr/local/share/oknav/ok_master
  [[ -f "$ok_master" ]] || ok_master="$SCRIPT_DIR"/ok_master

  if [[ "${1:-}" == @(-h|--help) ]]; then
    cat <<-'EOT'
	Usage: oknav list

	List all host symlinks in /usr/local/bin pointing to ok_master.
	Shows whether each host is defined in hosts.conf or added ad-hoc.

	Options:
	  -h, --help    Show this help
	EOT
    return 0
  fi

  # Load hosts.conf for status checking
  #shellcheck disable=SC2119
  load_hosts_conf

  # Find symlinks pointing to ok_master (match by target basename)
  local -a aliases=()
  local -- link name target

  while IFS= read -r link; do
    [[ -L "$link" ]] || continue
    target=$(readlink "$link")
    # Check if symlink target ends with ok_master
    [[ "${target##*/}" == "ok_master" ]] || continue
    name="${link##*/}"
    [[ "$name" == "ok_master" ]] && continue
    aliases+=("$name")
  done < <(find "$target_dir" -maxdepth 1 -type l 2>/dev/null | sort)

  # Display with status
  for name in "${aliases[@]}"; do
    if [[ -n "${ALIAS_TO_FQDN[$name]:-}" ]]; then
      printf '%-12s (hosts.conf)\n' "$name"
    else
      printf '%-12s (ad-hoc)\n' "$name"
    fi
  done
}

# Parse command line arguments
while (($#)); do
  case $1 in
    -x|--exclude-host)
      shift
      ok_server_excludes+=("$1");;
    -p|--parallel|parallel)
      PARALLEL=1 ;;
    -t|--timeout)
      shift
      TIMEOUT=${1:-30}  # Use provided timeout or keep default
      [[ "$TIMEOUT" =~ ^[0-9]+$ ]] || die 22 "Invalid timeout value ${TIMEOUT@Q}" ;;
    -D|--debug)
      DEBUG=1 ;;
    -V|--version)
      echo "$SCRIPT_NAME $VERSION"
      exit 0 ;;
    -h|--help|help)
      usage
      exit 0;;
    -[xptDVh]*)
      # Handle combined short options (e.g., -pD becomes -p -D)
      #shellcheck disable=SC2046
      set -- '' $(printf -- "-%c " $(grep -o . <<<"${1:1}")) "${@:2}" ;;
    --)
      # End of options, force multi-execute mode (bypass subcommand check)
      FORCE_EXEC=1
      shift
      break ;;
    -*)
      die 22 "Invalid option ${1@Q}" ;;
    *)
      # First non-option argument starts the command
      break ;;
  esac
  shift
done

# Handle subcommands (skip if -- was used to force multi-execute)
if ((! FORCE_EXEC)); then
  case "${1:-}" in
    install)
      shift
      install_symlinks "$@"
      exit $?
      ;;
    add)
      shift
      add_host "$@"
      exit $?
      ;;
    remove)
      shift
      remove_host "$@"
      exit $?
      ;;
    list)
      shift
      list_hosts "$@"
      exit $?
      ;;
  esac
fi

# If no command provided, show usage
(($#)) || { >&2 usage; exit 1; }

# Load hosts.conf configuration (auto-detects /etc/oknav/ or script directory)
#shellcheck disable=SC2119
load_hosts_conf

# Discover servers from hosts.conf with (oknav) option
# Apply exclusions from:
# 1. Command-line -x options (already in ok_server_excludes)
# 2. hosts.conf (exclude) options
# 3. hosts.conf (local-only) constraints

declare -a SERVERS=()
declare -- alias required_host

for alias in "${ALIAS_LIST[@]}"; do
  # Only include aliases marked with (oknav)
  is_oknav "$alias" || continue

  # Check for (exclude) option
  is_excluded "$alias" && continue

  # Check for (local-only) constraint violation
  required_host=$(get_local_only_host "$alias")
  if [[ -n "$required_host" && "$HOSTNAME" != "$required_host" ]]; then
    continue
  fi

  # Check command-line exclusions (-x options)
  if ((${#ok_server_excludes[@]})); then
    printf '%s\n' "${ok_server_excludes[@]}" | grep -Fxq "$alias" && continue
  fi

  SERVERS+=("$alias")
done

# Validate server discovery
if ((${#SERVERS[@]} == 0)); then
  if [[ -n "${1:-}" ]]; then
    error "No (oknav) servers found for command: ${1@Q}"
    # Suggest similar subcommand names for common typos
    case "$1" in
      instal|instll|inst|nstall)
        info "Did you mean: oknav install" ;;
      lst|lis|lsit)
        info "Did you mean: oknav list" ;;
      ad|adds|dad)
        info "Did you mean: oknav add" ;;
      remov|rm|del|delete|rmove)
        info "Did you mean: oknav remove" ;;
    esac
  fi
  die 1 "Ensure hosts.conf has entries with (oknav) option"
fi

# Debug output for server discovery
if ((DEBUG)); then
  debug "Discovered servers: ${SERVERS[*]}"
  debug "Command to execute: $*"
  debug "Execution mode: $( ((PARALLEL)) && echo 'parallel' || echo 'sequential')"
  debug "Timeout: $TIMEOUT seconds"
  debug "Temp directory: $TEMP_DIR"
fi

# ------------------------------------------------------------------------------
# run_command() - Execute command on single server (parallel mode helper)
# Captures output to temp file for ordered display after all complete.
# Args: server command [args...]
# Returns: 0 success, 1 temp file creation failed
# Timeout exit codes: 124=timeout, 125=timeout error, 126=command not found
# ------------------------------------------------------------------------------
run_command() {
  local -- server=$1
  local -- temp_file
  shift

  temp_file=$(mktemp "$TEMP_DIR"/"$SCRIPT_NAME"_"$server"_XXXXXX) || {
    error "Cannot create temporary file for ${server@Q}"
    return 1
  }
  TEMP_FILES+=("$temp_file")

  # Capture all output (stdout + stderr) to temp file
  { echo "+++$server:"
    timeout "$TIMEOUT"s sudo "$server" "$@" || {
      exit_code=$?
      case $exit_code in
        124) echo "Connection timeout after $TIMEOUT seconds" ;;
        125) echo 'Timeout command error' ;;
        126) echo "Command not found: $server" ;;
      esac
      true  # Continue regardless of error
    }
    echo
  } &> "$temp_file"

  # Write reference file for output collection phase
  echo "$temp_file" > "$TEMP_DIR"/."$SCRIPT_NAME"_"$server"_tempfile
  TEMP_FILES+=("$TEMP_DIR"/."$SCRIPT_NAME"_"$server"_tempfile)
}

# ==============================================================================
# Main Execution
# ==============================================================================
declare -i first=0

if (( PARALLEL )); then
  # --------------------------------------------------------------------------
  # PARALLEL MODE: All servers execute simultaneously, output collected after
  # --------------------------------------------------------------------------
  declare -a pids=()

  for server in "${SERVERS[@]}"; do
    run_command "$server" "$@" &
    pids+=($!)
  done

  # Wait for all background processes
  for pid in "${pids[@]}"; do
    wait "$pid" || true
  done

  # Display outputs in server order (not completion order)
  for server in "${SERVERS[@]}"; do
    temp_file_path="$TEMP_DIR"/."$SCRIPT_NAME"_"$server"_tempfile
    if [[ -f "$temp_file_path" ]]; then
      temp_file=$(<"$temp_file_path")
      if [[ -f "$temp_file" ]]; then
        ((first)) && echo || first=1
        cat "$temp_file"
      else
        warn "Output file for ${server@Q} not found"
      fi
      rm -f "$temp_file_path"
    fi
  done
else
  # --------------------------------------------------------------------------
  # SEQUENTIAL MODE: Execute on each server in order, display immediately
  # --------------------------------------------------------------------------
  for server in "${SERVERS[@]}"; do
    ((first)) && echo || first=1
    echo "+++$server:"
    timeout "$TIMEOUT"s sudo "$server" "$@" || {
      exit_code=$?
      case $exit_code in
        124) echo "Connection timeout after $TIMEOUT seconds" ;;
        125) echo 'Timeout command error' ;;
        126) echo "Command not found ${server@Q}" ;;
      esac
      true  # Continue regardless of error
    }
    echo
  done
fi

debug "Execution completed for ${#SERVERS[@]} servers"

# vim: set ts=2 sw=2 et:
#fin
