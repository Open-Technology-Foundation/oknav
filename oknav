#!/bin/bash
# OKnav System - Multi-server SSH command orchestrator
set -euo pipefail
shopt -s inherit_errexit

SCRIPT_PATH=$(realpath -e -- "$0")
SCRIPT_DIR=${SCRIPT_PATH%/*}
SCRIPT_NAME=${SCRIPT_PATH##*/}
readonly -- SCRIPT_PATH SCRIPT_DIR SCRIPT_NAME

#shellcheck source=common.inc.sh
source "$SCRIPT_DIR"/common.inc.sh || exit 1

# Runtime configuration
declare -i PARALLEL=0     # 0=sequential, 1=parallel execution
declare -i TIMEOUT=30     # default timeout
declare -a TEMP_FILES=()  # Track temp files for cleanup
declare -a ok_server_excludes=()  # Servers to exclude from execution

# Variables used throughout the script
declare -i exit_code               # SSH/timeout exit code
declare -- server                  # Current server being processed
declare -- pid                     # Process ID for parallel execution
declare -- temp_file               # Temporary file for output
declare -- temp_file_path          # Path to temp file reference

# Cleanup function - removes all temporary files
# Args: [exit_code] - Exit code to preserve (default: 0)
cleanup() {
  local -i exitcode=${1:-0}
  # Disable trap to prevent recursion
  trap - SIGINT SIGTERM EXIT
  # Remove tracked temp files
  local -- file
  for file in "${TEMP_FILES[@]}"; do
    [[ -f "$file" ]] && rm -f "$file"
  done
  # Remove any leftover temp files (parallel mode runs in subshells, so TEMP_FILES array isn't updated)
  rm -f "${TEMP_DIR:-/tmp}"/"${SCRIPT_NAME:-}"_*_* 2>/dev/null || true
  rm -f "${TEMP_DIR:-/tmp}"/."${SCRIPT_NAME:-}"_*_tempfile 2>/dev/null || true
  exit "$exitcode"
}
# Set up cleanup trap
trap 'cleanup $?' SIGINT SIGTERM EXIT

# Usage help function
usage() {
  cat <<EOT
$SCRIPT_NAME $VERSION - Multi-server SSH command orchestrator

Orchestrates command execution across all cluster servers.
Supports both sequential (default) and parallel execution modes. Servers
are discovered from hosts.conf entries marked with (oknav) option.

Security Note: Commands are executed with sudo privileges. This tool is
designed for administrators with existing server access.

Usage:
  $SCRIPT_NAME [OPTIONS] <command>          # Execute command on all servers
  $SCRIPT_NAME install [OPTIONS]            # Manage symlinks from hosts.conf
  $SCRIPT_NAME add <hostname> [alias...]    # Add ad-hoc host launcher
  $SCRIPT_NAME remove <alias>...            # Remove ad-hoc host launcher
  $SCRIPT_NAME [OPTIONS]                    # Show this help

Options:
  -p, --parallel         Execute commands in parallel across all servers
  -t, --timeout SECS     Set connection timeout in seconds (default: $TIMEOUT)
  -x, --exclude-host HOST  Exclude specific host from this execution (repeatable)
  -D, --debug            Enable debug output
  -h, --help             Display this help message
  -V, --version          Display version information

Examples:
  $SCRIPT_NAME uptime                       # Check uptime on all servers (sequential)
  $SCRIPT_NAME -p 'df -h'                   # Check disk space in parallel
  $SCRIPT_NAME -p 'systemctl status nginx'  # Check nginx status on all servers
  $SCRIPT_NAME -x ok0 uptime                # Exclude ok0 from this run
  $SCRIPT_NAME -D hostname                  # Debug mode to see server discovery
  $SCRIPT_NAME -t 60 'apt update'           # Update with 60-second timeout
  $SCRIPT_NAME -pt 10 uptime                # Parallel with 10-second timeout
  $SCRIPT_NAME install                      # Create symlinks from hosts.conf
  $SCRIPT_NAME install --dry-run            # Show what install would do
  $SCRIPT_NAME add ai.okusi.id              # Add launcher for ai.okusi.id
  $SCRIPT_NAME add ai.okusi.id ai ok-ai     # Add with custom aliases
  $SCRIPT_NAME remove ai ok-ai              # Remove launchers

Notes:
  - Commands are executed with sudo privileges
  - Servers are discovered from hosts.conf entries with (oknav) option
  - Servers with (exclude) option are excluded by default
  - Servers with (local-only:HOST) are excluded unless running from HOST
  - Use quotes for commands with special characters
  - Parallel mode creates temporary files in $TEMP_DIR
  - Connection timeout is $TIMEOUT seconds for unreachable servers

EOT
}

# install_symlinks() - Create/manage symlinks in /usr/local/bin
# Options: --dry-run, --remove-stale, --clean-local
install_symlinks() {
  local -i dry_run=0 remove_stale=0 clean_local=0
  local -- target_dir=/usr/local/bin
  local -i created=0 updated=0 skipped=0 removed=0

  # Detect ok_master location: installed (/usr/local/share/oknav/) or dev ($SCRIPT_DIR)
  local -- ok_master=/usr/local/share/oknav/ok_master
  [[ -f "$ok_master" ]] || ok_master="$SCRIPT_DIR"/ok_master

  # Parse install options
  while (($#)); do
    case $1 in
      -n|--dry-run) dry_run=1 ;;
      --remove-stale) remove_stale=1 ;;
      --clean-local) clean_local=1 ;;
      -h|--help)
          cat <<-EOT
Usage: $SCRIPT_NAME install [OPTIONS]
Manage symlinks in /usr/local/bin for all hosts.conf aliases

Options:
  -n, --dry-run      Show what would be done without making changes
  --remove-stale     Remove symlinks not in hosts.conf
  --clean-local      Remove local symlinks from $SCRIPT_DIR
  -h, --help         Show this help
EOT
        return 0
        ;;
      *)
        error "Unknown install option ${1@Q}"
        return 22
        ;;
    esac
    shift
  done

  # Load hosts.conf (auto-detects /etc/oknav/ or script directory)
  load_hosts_conf

  info "Installing symlinks to ${target_dir@Q}..."
  ((dry_run)) && info "(dry-run mode - no changes will be made)"

  # Create symlinks for all aliases in hosts.conf
  local -- alias target
  for alias in "${ALIAS_LIST[@]}"; do
    target="$target_dir/$alias"
    if [[ -L "$target" ]]; then
      if [[ "$(readlink "$target")" == "$ok_master" ]]; then
        ((++skipped))
      else
        info "  update: $alias (was: $(readlink "$target"))"
        ((dry_run)) || ln -sf "$ok_master" "$target"
        ((++updated))
      fi
    elif [[ -e "$target" ]]; then
      warn "$alias: file exists and is not a symlink - skipping"
    else
      info "  create: $alias"
      ((dry_run)) || ln -sf "$ok_master" "$target"
      ((++created))
    fi
  done

  # Remove stale symlinks (pointing to ok_master but not in hosts.conf)
  if ((remove_stale)); then
    local -- link name
    for link in "$target_dir"/ok*; do
      [[ -L "$link" ]] || continue
      [[ "$(readlink "$link")" == "$ok_master" ]] || continue
      name="${link##*/}"
      [[ -n "${ALIAS_TO_FQDN[$name]:-}" ]] && continue
      info "  remove: $name (not in hosts.conf)"
      ((dry_run)) || rm -f "$link"
      ((++removed))
    done
  fi

  # Clean local symlinks
  if ((clean_local)); then
    local -- link name
    for link in "$SCRIPT_DIR"/ok*; do
      [[ -L "$link" ]] || continue
      name="${link##*/}"
      info "  remove local: $name"
      ((dry_run)) || rm -f "$link"
      ((++removed))
    done
  fi

  echo
  info "Summary: $created created, $updated updated, $skipped unchanged, $removed removed"
  return 0
}

# add_host() - Add ad-hoc host launcher symlinks
# Usage: oknav add [-n] <hostname> [alias...]
# Creates symlinks in /usr/local/bin pointing to ok_master
add_host() {
  local -i dry_run=0
  local -- target_dir=/usr/local/bin

  # Detect ok_master location: installed (/usr/local/share/oknav/) or dev ($SCRIPT_DIR)
  local -- ok_master=/usr/local/share/oknav/ok_master
  [[ -f "$ok_master" ]] || ok_master="$SCRIPT_DIR"/ok_master

  # Parse options
  while (($#)); do
    case $1 in
      -n|--dry-run) dry_run=1 ;;
      -h|--help)
        cat <<-'EOT'
	Usage: oknav add [-n] <hostname> [alias...]

	Create symlinks for quick SSH access to a host.

	Arguments:
	  hostname    FQDN or IP (must be resolvable)
	  alias...    Symlink names (defaults to hostname if omitted)

	Options:
	  -n, --dry-run   Show what would be done without making changes
	  -h, --help      Show this help

	Examples:
	  oknav add ai.okusi.id             # Creates: ai.okusi.id → ok_master
	  oknav add ai.okusi.id ai ok-ai    # Creates: ai, ok-ai → ok_master
	EOT
        return 0 ;;
      -*) error "Unknown option ${1@Q}"; return 22 ;;
      *) break ;;
    esac
    shift
  done

  # Require hostname
  (($#)) || { error "Usage: oknav add [-n] <hostname> [alias...]"; return 1; }

  local -- hostname=$1; shift

  # Validate hostname is resolvable
  if ! getent hosts "$hostname" &>/dev/null; then
    error "Cannot resolve hostname: $hostname"
    return 1
  fi

  # Use hostname as alias if none provided
  local -a aliases=("${@:-$hostname}")

  ((dry_run)) && info "(dry-run mode - no changes will be made)"

  # Create symlinks
  local -- alias target
  for alias in "${aliases[@]}"; do
    target="$target_dir/$alias"
    if [[ -L "$target" ]]; then
      if [[ "$(readlink "$target")" == "$ok_master" ]]; then
        info "skip: $alias (already exists)"
      else
        info "update: $alias (was: $(readlink "$target"))"
        ((dry_run)) || ln -sf "$ok_master" "$target"
      fi
    elif [[ -e "$target" ]]; then
      warn "$alias: file exists and is not a symlink - skipping"
    else
      info "create: $alias → $hostname"
      ((dry_run)) || ln -sf "$ok_master" "$target"
    fi
  done
}

# remove_host() - Remove ad-hoc host launcher symlinks
# Usage: oknav remove [-n] <alias>...
# Removes symlinks from /usr/local/bin that point to ok_master
remove_host() {
  local -i dry_run=0
  local -- target_dir=/usr/local/bin

  # Detect ok_master for validation
  local -- ok_master=/usr/local/share/oknav/ok_master
  [[ -f "$ok_master" ]] || ok_master="$SCRIPT_DIR"/ok_master

  # Parse options
  while (($#)); do
    case $1 in
      -n|--dry-run) dry_run=1 ;;
      -h|--help)
        cat <<-'EOT'
	Usage: oknav remove [-n] <alias>...

	Remove symlinks created by 'oknav add'.

	Options:
	  -n, --dry-run   Show what would be done without making changes
	  -h, --help      Show this help

	Examples:
	  oknav remove ai                   # Remove single symlink
	  oknav remove ai ok-ai             # Remove multiple symlinks
	EOT
        return 0 ;;
      -*) error "Unknown option ${1@Q}"; return 22 ;;
      *) break ;;
    esac
    shift
  done

  # Require at least one alias
  (($#)) || { error "Usage: oknav remove [-n] <alias>..."; return 1; }

  ((dry_run)) && info "(dry-run mode - no changes will be made)"

  # Remove symlinks
  local -- alias target
  for alias in "$@"; do
    target="$target_dir/$alias"
    if [[ -L "$target" ]]; then
      if [[ "$(readlink "$target")" == "$ok_master" ]]; then
        info "remove: $alias"
        ((dry_run)) || rm -f "$target"
      else
        warn "$alias: symlink points elsewhere - skipping"
      fi
    elif [[ -e "$target" ]]; then
      warn "$alias: not a symlink - skipping"
    else
      warn "$alias: does not exist"
    fi
  done
}

# Parse command line arguments
while (($#)); do
  case $1 in
    -x|--exclude-host)
      shift
      ok_server_excludes+=("$1");;
    -p|--parallel|parallel)
      PARALLEL=1 ;;
    -t|--timeout)
      shift
      TIMEOUT=${1:-30}  # Use provided timeout or keep default
      [[ "$TIMEOUT" =~ ^[0-9]+$ ]] || die 22 "Invalid timeout value ${TIMEOUT@Q}" ;;
    -D|--debug)
      DEBUG=1 ;;
    -V|--version)
      echo "$SCRIPT_NAME $VERSION"
      exit 0 ;;
    -h|--help|help)
      usage
      exit 0;;
    -[xptDVh]*)
      # Handle combined short options (e.g., -pD becomes -p -D)
      #shellcheck disable=SC2046
      set -- '' $(printf -- "-%c " $(grep -o . <<<"${1:1}")) "${@:2}" ;;
    -*)
      die 22 "Invalid option ${1@Q}" ;;
    *)
      # First non-option argument starts the command
      break ;;
  esac
  shift
done

# Handle subcommands
case "${1:-}" in
  install)
    shift
    install_symlinks "$@"
    exit $?
    ;;
  add)
    shift
    add_host "$@"
    exit $?
    ;;
  remove)
    shift
    remove_host "$@"
    exit $?
    ;;
esac

# If no command provided, show usage
(($#)) || { >&2 usage; exit 1; }

# Load hosts.conf configuration (auto-detects /etc/oknav/ or script directory)
load_hosts_conf

# Discover servers from hosts.conf with (oknav) option
# Apply exclusions from:
# 1. Command-line -x options (already in ok_server_excludes)
# 2. hosts.conf (exclude) options
# 3. hosts.conf (local-only) constraints

declare -a SERVERS=()
declare -- alias required_host

for alias in "${ALIAS_LIST[@]}"; do
  # Only include aliases marked with (oknav)
  is_oknav "$alias" || continue

  # Check for (exclude) option
  is_excluded "$alias" && continue

  # Check for (local-only) constraint violation
  required_host=$(get_local_only_host "$alias")
  if [[ -n "$required_host" && "$HOSTNAME" != "$required_host" ]]; then
    continue
  fi

  # Check command-line exclusions (-x options)
  if ((${#ok_server_excludes[@]})); then
    printf '%s\n' "${ok_server_excludes[@]}" | grep -Fxq "$alias" && continue
  fi

  SERVERS+=("$alias")
done

# Validate server discovery
((${#SERVERS[@]})) || die 1 "No servers with (oknav) option found in hosts.conf"

# Debug output for server discovery
if ((DEBUG)); then
  debug "Discovered servers: ${SERVERS[*]}"
  debug "Command to execute: $*"
  debug "Execution mode: $( ((PARALLEL)) && echo 'parallel' || echo 'sequential')"
  debug "Timeout: $TIMEOUT seconds"
  debug "Temp directory: $TEMP_DIR"
fi

# Execute command on a single server (used in parallel mode)
# Creates a temporary file to capture output for later display
# Args: server_name command [args...]
# Returns: 0 on success, 1 on temp file creation failure
run_command() {
  local -- server=$1
  local -- temp_file
  shift
  
  # Create secure temporary file
  temp_file=$(mktemp "$TEMP_DIR"/"$SCRIPT_NAME"_"$server"_XXXXXX) || {
    error "Cannot create temporary file for ${server@Q}"
    return 1
  }
  
  # Track temp file for cleanup
  TEMP_FILES+=("$temp_file")
  
  # Execute and capture output
  { echo "+++$server:"
    # Execute command via sudo with timeout protection
    # timeout exit codes: 124=timeout reached, 125=timeout error, 126=command not found
    timeout "$TIMEOUT"s sudo "$server" "$@" || {
      exit_code=$?
      if ((exit_code == 124 )); then
        echo "Connection timeout after $TIMEOUT seconds"
      elif ((exit_code == 125 )); then
        echo 'Timeout command error'
      elif ((exit_code == 126 )); then
        echo "Command not found: $server"
      fi
      true  # Continue execution regardless of error
    }
    echo
  } &> "$temp_file"
  
  # Store temp file path reference for collection phase
  echo "$temp_file" > "$TEMP_DIR"/."$SCRIPT_NAME"_"$server"_tempfile
  
  # Track reference file for cleanup
  TEMP_FILES+=("$TEMP_DIR"/."$SCRIPT_NAME"_"$server"_tempfile)
}

# Main execution logic
declare -i first=0

if (( PARALLEL )); then
  # PARALLEL MODE: Execute commands on all servers simultaneously
  declare -a pids=()
  declare -- pid

  # Start background processes for each server
  for server in "${SERVERS[@]}"; do
    run_command "$server" "$@" &
    pids+=($!)  # Store process ID for later waiting
  done

  # Wait for all background processes to complete
  for pid in "${pids[@]}"; do
    wait "$pid" || true  # Ignore exit status of individual servers
  done

  # Collect and display outputs in server order
  for server in "${SERVERS[@]}"; do
    temp_file_path="$TEMP_DIR"/."$SCRIPT_NAME"_"$server"_tempfile
    
    # Find the temp file for this server
    if [[ -f "$temp_file_path" ]]; then
      temp_file=$(<"$temp_file_path")
      
      if [[ -f "$temp_file" ]]; then
        ((first)) && echo || first=1  # Add separator between outputs
        cat "$temp_file"
      else
        warn "Output file for ${server@Q} not found"
      fi
      
      # Clean up temp file reference
      rm -f "$temp_file_path"
    fi
  done
else
  # SEQUENTIAL MODE: Execute commands on servers one by one
  for server in "${SERVERS[@]}"; do
    ((first)) && echo || first=1  # Add separator between outputs
    echo "+++$server:"
    
    # Execute command via sudo with timeout protection
    timeout "$TIMEOUT"s sudo "$server" "$@" || {
      exit_code=$?
      if (( exit_code == 124 )); then
        echo "Connection timeout after $TIMEOUT seconds"
      elif (( exit_code == 125 )); then
        echo 'Timeout command error'
      elif (( exit_code == 126 )); then
        echo "Command not found ${server@Q}"
      fi
      true  # Continue execution regardless of error
    }
    echo
  done
fi

# Debug completion message
debug "Execution completed for ${#SERVERS[@]} servers"

# vim: set ts=2 sw=2 et:
#fin
